hey everyone welcome to simply learns
youtube channel
today we will be discussing about stack
versus heap and memory allocation
but before we begin let me tell you guys
that we have daily updates on multiple
technologies so if you are a tech geek
in a continuous hunt for the latest
technological advancements then consider
getting subscribed to our youtube
channel
and don't forget to hit that bell icon
to never miss an update from simplylearn
now without any further delay let's get
started with the agenda for today's
discussion
we will start this discussion by
understanding how memory stack operates
following which we will deal with stack
overflow error in programming
and finally we will understand how
memory heap operates
i hope i made myself clear with the
agenda
now let's get started with our first
topic which is understanding how memory
stack operates
but before diving directly into this
memory allocation structure
let's first analyze how exactly a
program utilizes memory in order to
execute itself
basically when we write a program in our
code editor it pre-processes the
complete code before even compilation
this preprocessing deals with the header
files
it expands the macros and other
constants declared with a hash sign
that means the libraries like standard
input output string dot h corner dot h
that we include an r code at the
beginning will get expanded for
utilizing inbuilt c functions following
that is the compilation when you press
the compile button in your code editor
the actual execution of your code begins
first the compiler checks for the errors
in your program and with the help of a
linker it converts the written code into
executable machine level code
this machine level code is in the form
of binary numbers that is 0 and 1.
and as we know machines only understand
this language of 0 and 1.
so once this executable machine level
code gets generated in a system the core
editor accesses the memory in order to
store variables and perform operations
the beginning part of this dot exe file
or machine code file is responsible for
allocating memory to the variables and
functions included in the program
the process of loading all data entities
into the memory is called loading and
the tool named loader in code editor is
responsible for that
well now you must be thinking about what
the code area in memory is
to answer this question let me tell you
guys that the memory compiler utilizes
to implement the code is known as random
access memory or ram which is further
segmented into three different blocks
the first block of this memory
segmentation or layout is called as code
area
this code area stores the machine level
code generated by the id and performs
the allocation commands inside it
if the variables objects or functions
used in the program are static in nature
then they get stored in the stack memory
area
whereas if they are of dynamic nature
they get stored in the heap memory area
having said that let's first understand
the static memory allocation using the
stack memory area the stack area
primarily stores the global variables in
the program and after that it stores all
the function calls and local variables
the local variables are the variables
declared inside the function whose life
span is equal to the time taken to
execute a program
additionally the amount of memory set
aside for this stack segment does not
grow while the application is running
that means the operating system
predefines the size of the stack and it
cannot be changed to better understand
this stack memory allocation using stack
let's take an example of a c program
in this simple c program we have a
function multiply that gives us the
product of two numbers
and we have a main method in which we
are just calling the multiply function
to get the product of numbers x and y
so let us see what happens in the memory
when this program executes
primarily there is no global variable in
our code hence the ide will directly
begin inserting methods and local
variables into the stack memory area
all of us know that when the program
starts executing the main method gets
invoked at first
thus in our program as well the main
method will get invoked first
and some amount of the memory from the
stack will be allocated to it
also the local variables inside the main
block will get some amount of memory
according to their data type
the memory allocated to the main block
inside the stack memory area is called
the stack frame for method main
and the size for this stack frame is
calculated when the program is compiling
now when the main calls multiply method
the stack frame for the function
multiply gets created
and inside it local variables n1 and n2
will remain until the function gets
executed
remember when the control is at a
statement in tem is equal to multiply
of x and y the state of our stack memory
area will look something like this
but once the control moves to the next
statement the multiply function will get
popped out of the stack area
and similarly when it reaches the end of
the main block the main function will
also get popped out from the memory
stack
when the main finishes the program will
also get terminated
and the console will return the output
of your program
next we will talk about the stack
overflow error in programming
when the program's execution starts an
operating system allocates some amount
of reserved space to the stack structure
for example let's say
os allocates 3mb space of ram to the
stack memory region
and the program that is present on the
screen is supposed to utilize this given
space
the simple c program that we have taken
here contains a method named fung
which is a recursive function
the function that calls itself
repeatedly until a certain condition
gets fulfilled is called the recursive
function
but if you observe this block of code
there is no stopping condition to halt
this recursive function
hence once the execution of a program
begins this function will keep invoking
itself
at first the main function will enter
the memory stack
after that the function named fun will
enter the stack memory area as the main
function invokes it
however once the function fun is invoked
there is no stopping condition to halt
it from getting executed repeatedly
so the function fund will keep on adding
in the stack until the stack memory is
exhausted
when the memory allocation process
occurring during runtime grows beyond
the reserved memory for the stack as we
have seen in the previous slide
this is called stack overflow error
to understand this better let's visit
the code editor
for this particular code we will be
checking how the stack overflow error
happens
so let's just compile this code
okay as you can see on your screens our
code has started with the execution and
function fun is calling itself again and
again
so let's wait until a stack memory gets
exhausted
as you can see on your screen right now
our program has failed because of a
stack overflow error
this error is occurring due to an
infinite recursion of the function fun
i hope you're clear with this stack
overflow error now
so let's go back to our presentation now
now let's understand the memory heap
region in programming
we understood that we could not
manipulate the scope of a variable which
is getting stored in the stack
or if we want to create a large array
for which we are unable to specify size
then we cannot declare it in the case of
stack memory
but when it comes to heap memory both of
these problems can be fixed
unlike stack the heap memory area is not
fixed
its size can vary during the run time of
a program
additionally there are no set of rules
for the allocation and deallocation of
memory
a programmer can totally control how
much memory to use from the heap until
what time to keep the data in memory
during the program's lifetime and heap
can grow as long as you do not run out
of memory on the system itself
that is a dangerous thing also and we
need to be really careful about using
heap for this reason
in the c programming language we have
functions named malloc catalog realog
and free
allowing us to manipulate storage in the
heap memory area
and the objects or variables that we are
going to create using these functions
are going to be of dynamic nature
so let's understand the process of
dynamic memory allocation using a c
program
in this c program we have created a
pointer z for which we are allocating
dynamic memory using the malloc function
the malloc function asks for how much
memory to give on the heap memory area
in bytes
when we call malloc and pass an argument
size of an integer then we are
commanding over ide to provide us with
four bytes of random memory
once the size is allocated on the heap
memory region the malloc will return the
void pointer to starting address of a
created new block
in this case it will be 200.
when malloc returns this address to us
we will use typecasting to store an
element at any given memory address
additionally if i want to remove this
variable from memory address 200 i can
call function free to deallocate the
memory
in this case when i add line free of c
the reference to address 200 will get
destroyed and the data variable present
at that address will get removed
automatically
but again i can use the malloc function
to generate an address reference for the
same pointer c such that it will point
to a new memory address with the new
value as well
in this case the newly created void
pointer provides us with the address
value 48
and by using typecasting we are storing
value 9 at that pointed location moving
ahead let's also discuss about the heap
overflow condition
the heap overflow is a hypothetical
condition in which the operating system
becomes unable to provide more memory to
the heap memory layout
this is considered to be a hypothetical
condition as these days computer systems
come up with massive ram storages
but there are two scenarios that still
can cause a heap overflow error
the first one is when we continuously
allocate memory without deallocating
previously allocated memory space
in this case ram memory is ultimately
getting used for heap storage
but it is unavailable for other
processes
if this scenario happens in your program
then there are high chances of getting
your ram crashed and eventually it will
lead to a deadlock or freezing of other
main os programs
the second scenario is about explicit
memory allocation to the massive number
of variables
in this case the ram gets completely
filled with heap area and the computer
enters in a deadlock situation
on that note let's visit the code editor
and build up the programs for both these
cases
we'll build codes for each of these
scenarios here but we won't run them
since i don't want this session to stop
because of a ram or system crash
i would also prefer that you people
should also learn the theory behind heap
overflow rather than running it because
it could cause problems in your
computers or laptops as well
in the first case we want to allocate
huge memory to the heap area without
using any de-allocation operation
so to do that i will use a for loop
running till the huge number and for
each iteration it will generate four
bytes of memory on the heap
the lines of code that will allow us to
do that are
for i is equal to 0 to i is equal to
this enormous number we will produce an
iteration
and inside this iterative block we will
keep allocating memory to innumerable
integer variables
and in the second case we just want to
allocate memory to the massive number of
variables
so again the code for this will be a
one-liner where we will be passing the
number of variables to the malloc
argument field the line of code that
will allow us to do that is int star ptr
is equal to int star malloc allocating
integer variables using the size of
function for huge range
remember guys it's not a good practice
to implement these heap overflow
scenarios in your systems as you can
clearly see the massive storage
complexity associated with these lines
of code
so refrain from executing them in your
systems now let's go back to our
presentation and contemplate all the key
differences that we have understood till
this time
the first takeaway from this discussion
is stack memory stores only static
variables
whereas heap memory stores dynamic
variables
the next difference between stack memory
and heap memory is that the stack
overflow error happens when there is no
halting condition for function
invocation in a program
in contrast the heap overflow occurs due
to the allocation of enormous memory
area to dynamic variables
however these errors are almost
impossible to happen as we do not
directly allocate huge memory space to
dynamic variables
next up is the thread access for stack
and heap memory allocations
the stack memory allocation is
considered safer than heap memory
allocation as the owner threat can only
access the data stored inside the stack
meanwhile in the case of heap it can be
accessed by any thread in a system
the last key difference between stack
and heap on our list is
stack frame access is easier than keep
frame access
because the stack has a small memory
region and is cache friendly
still keyframes are scattered throughout
the memory resulting in more cache
misses
with this we have come to the end of
this video i hope this video on stack
versus heap in memory allocation was
informative and exciting
if you have any queries regarding the
topics that were covered in this video
then let us know about them in the
comments section below and we will get
back to you
thank you so much for being here and do
watch out for more videos from us
until then keep learning and stay tuned
to simply learn
hi there if you like this video
subscribe to the simply learn youtube
channel and click here to watch similar
videos to nerd up and get certified
click here